# 다중화와 역다중화

다중화와 역다중화는 모든 컴퓨터 네트워크에 필요하다.

목적지 호스트에서의 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 세그먼트를 수신한다.

트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 이 세그먼트의 데이터를 전달하는 의무를 진다.

예를 들어, 하나의 FTP세션과 2개의 텔넷 세션을 실행하면서 웹 페이지를 다운로드 하고 있다면, 4개의 네트워크 애플리케이션 프로세스를 갖는다.

우리는 이 4개의 프로세스 중 하나에게 수신한 데이터를 전달할 필요가 있다.

![Untitled](https://user-images.githubusercontent.com/86337233/211320111-82e0f6d5-f5f7-436c-8d5c-a3be0b178547.png)

먼저 소켓을 통해 데이터를 전달 받거나 전달하므로, 위의 사진처럼 받는 트랜스포트 계층이 실제로 데이터를 직접 애플리케이션 계층의 프로세스로 전달하지 않는다.(대신 중간 매개자인 소켓에게 전달한다.)

어떤 주어진 시간에 수신 측 호스트에 하나 이상의 소켓이 있을 수 있으므로, 각각의 소켓은 하나의 유일한 식별자를 갖는다.(UDP인지 TCP인지에 따라 다르다.)

수신 측 호스트가 수신한 트랜스포트 계층 세그먼트를 어떻게 적절한 소켓으로 향하게 할까?

각각의 트랜스포트 계층 세그먼트는 이러한 목적을 위해 세그먼트에 필드 집합을 갖고 있다.

수신 측의 트랜스포트 계층은 수신 소켓을 식별하기 위해 필드를 검사한다.

그리고 이 세그먼트를 해당 소켓으로 보낸다.

트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 `역다중화`라고 한다.

출발지 호스트에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업을 `다중화`라고 한다.

위 사진에서 중간 호스트의 트랜스포트 계층은 네트워크 계층 아래로부터 수신한 세그먼트를 위쪽의 프로세스 P1또는 P2로 반드시 역다중화해야 한다.

도착한 세그먼트의 데이터가 이에 상응하는 프로세스의 소켓으로 전달되도록 해서 이루어진다.

또한 중간 호스트의 트랜스포트 계층은 프로세스의 소켓으로부터 외부로 나가는 데이터를 모으고, 다음엔 트랜스포트 계층 세그먼트들로 만들고, 이 세그먼트들을 아래 네트워크 계층으로 전달해야만 한다.(다중화)

트랜스포트 계층이나 그 밖의 계층에서의 한 프로토콜이 그 상위 계층의 여러 프로토콜에 의해 사용될 때마다 관련되어 있다.

![Untitled](https://user-images.githubusercontent.com/86337233/211320125-ff37b76f-2ad8-43d8-9b1a-56872c592a5c.png)

실제 호스트에서 다중화와 역다중화는 어떻게 실행될까?

트랜스포트 계층에서 다중화할 때 두가지 요구 사항이 있는데, 다음과 같다.

1. 소켓은 유일한 식별자를 갖는다.
2. 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖는다.

위에 사진에서 보면, 두번째에세 이야기한 특별한 필드는 출발지 포트 번호 필드, 목적지 포트 번호 필드가 있다.

- 각 포트 번호는 0 ~ 65535(2^16-1)까지의 16비트 정수다. 그중에서 0~1023까지의 포트 번호를 잘 알려진 포트 번호라고 하여 사용을 엄격하게 제한하고 있다.
- 만약 새 애플리케이션을 개발할 때는 애플리케이션에 포트 번호를 반드시 할당해야 한다.

호스트의 각 소켓은 포트 번호를 할당받는다. 그리고 세그먼트가 호스트에 도착하면,

트랜스포트 계층은 세그먼트 안의 목적지 포트 번호를 검사하고 상응하는 소켓으로 세그먼트를 보내게 된다.

그러면 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다.

### 비연결형 다중화와 역다중화

2.7.1에서 작성한 코드 중에 UDP소켓을 다음과 같이 생성할 수 있다.

`clinetSocket = socket(AF_INET, SOCK_DGRAM)`

이 방법으로 UDP소켓이 생성될 때, 트랜스포트 계층은 포트 번호를 소켓에게 자동으로 할당한다.

특히 트랜스포트 계층은 현재 호스트에서 UDP포트로 사용하지 않는 1024~65535 사이의 포트 번호를 할당한다.

다른 방법으로 `bind()`를 사용해 특정 포트 번호를 UDP소켓에 할당하기 위해 한 줄을 추가할 수 있다.

`clientSocket.bind((’’, 19157))`

만약 코드를 작성하는 개발자가 ‘잘 알려진 프로토콜’의 서버 측을 구현하고 있다면, 개발자는 상응하는 ‘잘 알려진 포트 번호’를 할당해야 한다.

일반적으로 애플리케이션의 서버측이 특정 포트를 할당하지만, 클라이언트측은 트랜스포트 계층이 포트 번호를 자동으로 할당한다.

UDP 소켓이 목적지 IP주소와 목적지 포트 번호로 구성된 두 요소로 된 집합에 의해 식별된다.

만약 2개의 UDP세그먼트가 출발지 IP주소와 출발지 포트 번호가 모두 다르거나 출발지 IP주소와 출발지 포트 번호 중 어느 하나가 다를지라도, 같은 목적지 IP주소와 목적지 포트 번호를 가지면 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것이다.

![Untitled](https://user-images.githubusercontent.com/86337233/211320120-b319557b-49d0-47d8-a7f5-671cb51131d8.png)

출발지 포트 번호는 무슨 목적으로 사용될까?

위의 사진처럼, 출발지 포트 번호는 ‘회신 주소’의 한 부분으로 사용된다.

이는 UDPServer.py에서 확인할 수 있는데,

`recvfrom()`함수를 통해 출발지 포트번호를 추출한다.

그러면 이 포트 번호를 사용하여 새로운 목적지 포트 번호로 사용하여 새로운 세그먼트를 클라이언트에게 전송한다.

### 연결지향형 다중화와 역다중화

TCP역다중화를 수행하기 위해 TCP 소켓과 TCP연결 설정을 살펴봐야 한다.

UDP와 다른 점은 TCP 소켓은 4개 요소의 집합, 즉 `(출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호)`에 의해 식별된다.

그래서 네트워크로부터 호스트에 TCP세그먼트가 도착하면, 호스트는 해당되는 소켓으로 세그먼트를 전달하기 위해 4개의 값을 모두 사용한다.

특히, UDP와는다르게 다른 출발지 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향하게 된다.

2.7의 TCP 서버/클라이언트 프로그램을 살펴보면,

- TCP 서버 애플리케이션에서는 ‘환영 소켓’을 가지고 있다.
- TCP 클라이언트는 다음과 같은 명령으로 소켓을 생성하고 연결 설정 요청 세그먼트를 보낸다.
  `clientSocket = socket(AF_INET, SOCK_STREAM)`
  `clientSocket.connect((serverName, 12000))`
- 연결 설정 요청은 목적지 포트 번호 12000과 TCP헤더에 설정된 특별한 연결 설정 비트를 가진 TCP 세그먼트에 지나지 않는다.
  그리고 그 세그먼트는 출발지 포트 번호를 포함하는데, 이 출발지 포트 번호는 클라이언트가 선택한 번호이다.
- 서버 프로세스로 동작하는 컴퓨터의 호스트 운영체제가 목적지 포트 12000을 포함하는 연결 요청 세그먼트를 수신하면, 이 세그먼트를 포트 번호 12000으로 연결수락을 기다리는 서버 프로세스를 보낸다.
  connectionSocket, addr = serverSocket.accept()
- 또한 서버는 연결 요청 세그먼트의 다음과 같은 네가지 값을 주목한다.
  1. 세그먼트안의 출발지 포트 번호
  2. 출발지 호스트의 IP주소
  3. 세그먼트 안의 목적지 포트 번호
  4. 목적지 IP주소
  새롭게 생성된 연결 소켓은 이 네가지 값에 의해 식별된다.
  그 다음에 도착하는 모든 세그먼트의 요소 네가지 값과 일치하면, 세그먼트는 이 소켓으로 역다중화될 것이다.
  적절한 TCP연결과 함께 클라이언트와 서버는 데이터를 서로 주고받을 수 있다.

![Untitled](https://user-images.githubusercontent.com/86337233/211320137-5c90b955-b4b2-4dcb-ab04-8f25e6b24d2e.png)

서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다.(4개 요소의 집합이 모두 맞다면 가능하다.)

위의 사진에서 호스트 C가 서버 B로 2개의 HTTP세션을 시작하고,

호스트 A가 호스트 B로 하나의 HTTP세션을 시작하는 상황이 설명되어 있다.

여기서 중요한 점은, 호스트 A와 호스트 C의 세션 하나하고 출발지 포트 번호가 같더라도 IP주소가 달라 독립적이므로 서버 B는 두 연결을 올바르게 역다중화할 수 있다.

### 웹 서버와 TCP

아파치 웹 서버같은 웹 서버가 포트 번호 80상에서 동작하는 호스트를 고려해보자.

브라우저가 서버로 세그먼트를 보내면, 모든 세그먼트는 목적지 포트 번호 80을 갖고 있을 것이다.

특히, 초기 연결 설정 세그먼트들과 HTTP요청 메시지를 전달하는 모든 세그먼트는 목적지 포트번호 80을 가질 것이다.

위의 그림에서는 일대일 대응을 하지만, 실제로는 항상 일대일 대응을 하지 않는다.

오늘날 많은 고성능 웹 서버는 하나의 프로세스만 사용한다. 그러면서, 각각의 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 스레드(서브프로세스)를 생성한다.

만약 클라이언트와 서버가 지속적인 HTTP를 사용한다면, 지속적인 연결이 존속 기간에 클라이언트와 서버는 같은 서버 소켓을 통해 HTTP메시지를 교환할 것이다.

하지만 비 지속적인 HTTP를 사용한다면, 매번 모든 요청/응답마다 TCP연결이 생성되고 종료될 것이다.

이 것은 웹서버에 심한 부담을 준다.

부록: 정말 서버 프로세스 하나만 사용할까?

참고:https://okky.kr/questions/721501

프로세스는 프로그램의 단위이며,

애플리케이션을 하나 만들었을 때, 프로세스는 하나가 있고, 내부에는 여러개의 스레드를 가지게 된다.

참고로, 자바스크립트를 사용하면 스레드는 하나밖에 사용못하고, 그외 다른 언어들(자바, 파이썬, C등등) 대부분은 멀티스레드를 사용 가능하다.
