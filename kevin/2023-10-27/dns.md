# DNS: 인터넷의 디렉터리 서비스

인터넷호스트의 식별자 중 하나는 호스트 이름이 있지만, 이름의 길이가 가변적이고 그 호스트의 위치를 나타내지 않으므로 라우터가 처리하는데 어려움이 있다.

그래서 호스트는 고정된 길이의 IP주소로 식별된다.

### DNS(domain name system)

1. DNS서버들의 계층구조로 구현된 분산 데이터베이스이고
2. 호스트가 분산 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜이다.

DNS서버는 주로 BIND(Berkeley Internet Name Domain) 소프트웨어를 수행하는 유닉스 컴퓨터다.

DNS 프로토콜은 UDP상에서 수행되고 포트 번호 53을 이용한다.

DNS는 다른 애플리케이션 프로토콜들이 HTTP, SMTP, FTP등 사용자가 제공한 호스트에서 수행되는 브라우저가 URL을 요청할 때(HTTP요청 메시지를 웹서버 www.naver.com으로 보낼 때) 사용자는 www.naver.com의 IP주소를 얻어야만 한다.

이 과정은

1. 같은 사용자 컴퓨터는 DNS애플리케이션의 클라이언트 측을 수행한다.
2. 브라우저는 URL로 부터 호스트 이름 www.naver.com을 추출하고 그 호스트 이름을 DNS 애플리케이션의 클라이언트 측에 넘긴다.
3. DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하는 질의를 보낸다.
4. DNS 클라이언트는 결국 호스트 이름에 대한 IP주소를 가진 응답을 받게 된다.
5. 브라우저가 DNS로부터 IP주소를 받으면, 브라우저는 해당 IP주소와 그 주소의 80포트에 위치하는 HTTP서버 프로세스로 TCP연결을 초가화한다.

이 과정을 보면 DNS를 사용하는 인터넷 애플리케이션에게 추가 지연을 준다는 것을 볼 수 있다.(다행히 IP주소는 가까운 DNS서버에 캐싱되어 있다.)

DNS는 호스트 이름을 IP주소로 변환하는 것 외에 추가 서비스를 제공한다.

- 호스트 에일리어싱: 복잡한 호스트 이름을 가진 호스트는 하나 이상의 별명을 가진다.(예를 들어, relay1.west-cost.enterprise.com과 같은 호스트이름은 enterprise.com과 같은 2개의 별칭을 가질 수 있다. 이 경우 relay1.west-cost.enterprise.com은 정식 호스트 이름이라고 한다.)
- 메일 서버 에일리어싱: 전자메일 주소가 ——@relay1.west-cost.hotmail.com처럼 긴 경우 뒤의 호스트 이름도 별칭을 갖는 것을 허용한다. 애초에 MX 레코드는 기업의 메일 서버와 웹 서버가 같은 호스트 이름을 갖는 것을 허용한다.
- 부하 분산: DNS는 여러 중복 웹 서버와 같은 중복 서버 사이에 부하를 분산하기 위해 사용되고 있다. 특히 인기 있는 사이트들은 각 서버가 다른 종단시스템에서 수행되고 다른 IP주소를 갖는다.(웹 서버의 경우 여러 IP주소가 하나의 정식 호스트 이름과 연관되어 있다. IP주소들은 DNS데이터베이스에 저장되어 있다.) 클라이언트가 주소 집합으로 매핑하는 호스트 이름에 대한 DNS질의를 하면, 서버는 IP 주소 집합 전체를 가지고 응답한다.(응답은 순환식으로 보낸다.) 클라이언트는 보통 첫번쨰 IP주소로 HTTP 요청 메시지를 보내므로 트래픽 분산 효과를 낸다.

### DNS 동작 원리 개요(호스트 이름을 IP주소로 변환하는 서비스 위주)

위에서

1. 같은 사용자 컴퓨터는 DNS애플리케이션의 클라이언트 측을 수행한다.
2. 브라우저는 URL로 부터 호스트 이름 www.naver.com을 추출하고 그 호스트 이름을 DNS 애플리케이션의 클라이언트 측에 넘긴다.
3. DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하는 질의를 보낸다.
4. DNS 클라이언트는 결국 호스트 이름에 대한 IP주소를 가진 응답을 받게 된다.
5. 브라우저가 DNS로부터 IP주소를 받으면, 브라우저는 해당 IP주소와 그 주소의 80포트에 위치하는 HTTP서버 프로세스로 TCP연결을 초가화한다.

이와 같은 과정을 수행하는데, 조금 살을 붙여보자면

2번에서 애플리케이션은 변환될 호스트이름을 명시하여 DNS측의 클라이언트를 호출할 것이다.(많은 유닉스 기반 컴퓨터가 그렇듯 gethostbyname()은 변환을 실행하기 위한 애플리케이션을 호출하는 함수다.)

3번에서 사용자 호스트의 DNS는 네트워크에 질의 메시지를 포트 53의 UDP 데이터그램으로 보내진다.

4번에서 수 밀리초에서 수 초의 지연 후 사용자 호스트의 DNS는 요청한 매핑에 해당하는 DNS응답 메시지를 받는다.이 매핑은 호출한 애플리케이션으로 전달된다.

애플리케이션 사용자 관점에서 DNS는 일종의 간단하고 직접적인 변환 서비스를 제공하는 블랙박스다.

하지만 DNS는 복잡한데, 이는 전 세계에 분산된 많은 DNS서버 뿐만 아니라 DNS서버와 질의를 하는 호스트 사이에서 어떻게 통신하는지를 명시하는 애플리케이션 계층 프로토콜로 구성되어 있다.

DNS를 중앙 집중 방식처럼 작동할 것 같지만, 이 방식의 문제점은 다음과같다.

- 서버의 고장: 서버가 고장나면 전체 인터넷이 작동하지 않는다.
- 트래픽양: 단일 DNS 서버가 모든 DNS 질의를 처리해야 한다.
- 먼 거리의 중앙 집중 데이터베이스: 모든 DNS 질의가 단일 DNS서버와 가까울 순 없다.
- 유지관리: 모든 인터넷 호스트에 대한 레코드를 유지해야 한다. 중앙 집중 데이터베이스는 거대하지고 모든 새로운 호스트를 반영하기 위해 자주 갱신해야 한다. 또한 인증 문제도 있다.

이를 요약하면, 단일 DNS 서버에 있는 중앙 집중 데이터베이스는 확장성이 전혀 없다. 그래서 DNS는 분산되도록 설계되어 있다.

![Untitled](https://user-images.githubusercontent.com/76640167/210617280-e684c1b7-4f6c-4224-af7e-2e88334bdea2.png)

### 분산 계층 데이터베이스

위의 그림처럼, DNS 단일 서버는 인터넷에 있는 모든 호스트에 대한 매핑을 갖지 않는 대신에 DNS서버 사이에 분산된다.

각 위치의 DNS서버에 대해 알아보자면,

- 루트 DNS서버: 1000개 이상의 루트 서버 인스턴스가 전 세계에 흩어져 있다. 인터넷 할당 번호 관리기관에 의해 조정되며, TLD 서버의 IP주소들을 제공한다.
- 최상위 레별 도메인(TLD) 서버: .com과 같은 상위 레벨 도메인과 kr과 같은 모든 국가의 상위레벨 도메인에 대한 TLD서버다. .com은 베리사인 글로벌 레지스트리 서비스사에서 담당하고 있ㅇ며, 에듀코즈사는 .edu에 대한 TLD서버를 담당하고 있다. TLD를 지원하는 네트워크 인프라는 크고 복잡하다. 마지막으로 책임 DNS서버에 대한 IP주소를 제공한다.
- 책임 DNS서버: 인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 이름을 IP주소로 매핑하는 공개적인 DNS레코드를 제공해야 한다. 기관의 책임 DNS서버는 이 DNS레코드를 가지고 있고, 이 레코드를 갖도록 자신의 책임 DNS서버의 구현을 선택할 수 있으며, 일부 서비스 제공자의 책임 DNS서버에 이 레코드를 저장하도록 비용을 지불한다. 대부분의 기업과 대학들에서 이 서버를 유지하고 관리한다.

여기서 DNS 구조의 중심에 있는 로컬 DNS서버도 있는데, ISP(인터넷 서비스 제공자)는 로컬 DNS서버를 통해 호스트에게 IP주소를 제공한다. 윈도우나 유닉스에서 네트워크 상태 창에 접근하여 로컬 DNS서버의 IP주소를 쉽게 결정할 수 있다.

이제 호스트가 cse.nyu.edu에서 gaia.cs.umass.edu의 IP주소를 받는 다고 가정하자.

![Untitled](https://user-images.githubusercontent.com/76640167/210620114-71bda09c-0995-410a-b8e1-70ee1c5b76bd.png)

1. 호스트는 로컬 DNS서버에게 gaia.cs.umass.edu에 관한 DNS질의 메시지를 보낸다.
2. 로컬 DNS서버는 루트 DNS서버에게 그 질의 메시지를 보낸다.
3. 루트 DNS서버는 .edu를 인식하고 로컬 DNS서버에게 edu의 책임을 가진 TLD DNS 서버의 IP주소 목록을 로컬 DNS서버에게 보낸다.
4. 로컬 DNS서버는 해당 TLD DNS서버의 IP주소를 통해 질의 메시지를 보낸다.
5. TLD DNS 서버는 umass.edu를 인식하고 로컬 DNS서버에게 dns.umass.edu로 이름 지어진 책임 DNS 서버의 IP주소로 응답한다.
6. 로컬 DNS서버는 해당 책임 DNS서버로 질의 메시지를 보내고 gaia.cs.umass.edu의 IP주소로 응답한다.

이렇게 총 8번의 응답과 질의가 오갔는데, TLD DNS서버는 사실 책임 DNS서버를 알지는 않고 그위의 중간 DNS서버만 알고 있기 때문에 실제로는 10번의 질의와 응답이 오갔다.

여기서 위의 사진에는 재귀적 질의와 반복적 질의를 사용하는데, 1번만 재귀적 질의이고, 나머지는 반복적 질의이다.

아래의 사진은 재귀적 질의만으로 DNS 질의 사슬을 나타낸다.

전부 재귀적인 DNS와 관련한 cloudflare문서: https://www.cloudflare.com/ko-kr/learning/dns/what-is-recursive-dns/

![Untitled](https://user-images.githubusercontent.com/76640167/210622856-0c967585-6ce3-45c7-97bd-c1ed6e3143fc.png)

DNS의 지연 성능 향상과 네트워크의 DNS메시지 수를 줄이기 위해 캐싱을 사용한다.

이를 사용하면 질의 없이 바로 로컬 DNS서버에게 IP주소를 보낼 수 있다.

## DNS 레코드와 메시지

DNS 분산 데이터베이스를 구현한 DNS 서버들은 호스트 이름을 IP주소로 매핑하기 위해 자원 레코드를 저장한다.

자원 레코드는 4개의 요소를 가진 튜플로 구성된다.

(Name, Value, Type, TTL)

- TTL: 자원 레코드의 생존 기간이다.(캐시에서 제거될 시간)
- Type=A이면 Name은 호스트 이름이고 Value는 호스트 이름에 대한 IP주소이다.(Type a 레코드는 표준 호스트 이름의 IP주소 매핑을 제공한다.)
- Type=NS이면 Name은 도메인이고 Value는 도메인 내부의 호스트에 대한 IP주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 이름이다.
- Type=CNAME이면 Value는 별칭 호스트 이름 Name에 대한 정식 호스트 이름이다.
- Type=MX이면 Value는 별칭 호스트 이름 Name을 갖는 메일서버의 정식 이름이다.

DNS 서버가 특별한 호스트 이름에 대한 책임 서버이면, 그 DNS 서버는 호스트 이름에 대한 Type A 레코드를 포함한다.

서버가 호스트 이름에 대한 책임 서버가 아니라면, 그 서버는 호스트 이름을 포함하는 DNS 서버의 IP 주소를 제공하는 Type A 레코드도 포함할 것이다.

### DNS메시지

HTTP메시지 처럼 DNS에도 요청과 응답 메시지에 포맷을 가지고 있다.

![Untitled](https://user-images.githubusercontent.com/76640167/210725479-3cc2dfe9-5ffd-49f8-9385-5cc244b7c2e6.png)

- 처음 12바이트(=96비트)는 헤더 영역으로, 여러 필드를 가지고 있다.
  각각 살펴 보면
  - Identification(식별자): 질의를 식별하는 16비트 숫자다. 이 식별자는 질의에 대한 응답 메시지에 복사되어, 클라이언트가 보낸 질의와 수신된 응답 간의 일치를 식별하게 한다.
  - Flag(플래그): 여러개의 플래그가 있는데,
    - 1비트의 질의/응답 플래그는 메시지가 질의(0)인지 응답(1)인지 구별하게 한다.
    - 1비트의 책임 플래그는 DNS 서버가 질의 이름에 대해 책임 서버일 때 응답 메시지에 설정된다.
    - 1비트의 재귀 요구 플래그는 DNS 서버가 레코드를 갖지 않을 때 재귀적 질의를 수행하기를 클라이언트가 원할 때 설정된다.
    - 1비트의 재귀 가능 플래그는 DNS 서버가 재귀 질의를 지원하면 응답에 설정된다.
  - 4개의 ‘개수’ 필드: 헤더 다음에 오는 데이터 영역의 네가지 타입의 발생 횟수를 나타낸다.
- 질문 영역: 현재 질의에 대한 정보를 포함한다. 이 영역은
  1. 질의되는 이름을 포함하는 이름 필드
  2. 이름에 대해 문의되는 질문타입을 나타내는 타입 필드
  두가지로 나타낸다.(이름과 연관된 호스트 주소(A 타입) 혹은 이름에 대한 메일 서버(MX타입) 등)
- (DNS 서버로부터의 응답에서) 답변 영역: 원래 질의된 이름에 대한 자원 레코드를 포함한다. 각 자원 레코드의 Type, Value, TTL이 있는데, 응답으로 여러 개의 자원 레코드 보낼 수 있다.(왜냐면 호스트 이름은 여러 개의 IP주소를 가질 수 있기 때문이다.)
- 책임 영역: 다른 책임 서버의 레코드를 포함한다.
- 추가 영역: 다른 도움이 되는 레코드를 포함하고 있다.(MX 질의에 대한 응답에서 응답 필드는 전자메일 서버의 정식 호스트 이름을 제공하는 자원 레코드를 갖고 있다. 추가 영역은 정식 호스트 이름에 대한 IP주소를 제공하는 Type A 레코드를 포함한다.)

어떻게 DNS질의 메시지가 우리가 작업하는 호스트로부터 DNS서버로 곧장 보내질 수 있을까?

→ 이것은 nslookup프로그램으로 쉽게 할 수 있는데, 윈도우와 유닉스에서 이용할 수 있다.

윈도우의 경우, cmd창을 열고 `nslookup` 을 입력하여 nslookup프로그램을 실행한다.

nslookup을 실행한 후에 우리는 DNS질의를 어떤 DNS 서버로 보낼 수 있다.

DNS 서버로 부터 응답 메시지를 받은 후 nslookup은 응답에 있는 레코드를 화면에 사람이 읽을 수 있는 형태로 보여준다.

인터넷에 nslookup을 원격으로 실행해 주는 사이트들 중 하나를 방문할 수 있다.

### DNS 데이터베이스에 레코드 삽입

위에서는 레코드가 DNS 데이터베이스로부터 어떻게 추출되는 지에 초점을 맞추었는데, 이번에는 DNS 데이터베이스에 레코드를 어떻게 넣는지 확인해 볼 것이다.

만약 네트워크 유토피아 라는 회사를 만들었다 가정해 보자.

1. 가장 먼저 할 일은 도메인 네임을 등록기관에 등록하는 것이다.

   등록 기관은 도메인 네임의 유일성을 확인하고, 그 도메인 이름을 DNS 데이터베이스에 넣고 그 서비스에 대한 약간의 요금을 우리로 부터 받는 상업 기관이다.(1990년 이전에는 네트워크 솔루션이라는 작은 기업이 여러 도메인에 대한 이름 등록을 독점했지만, 이제는 고객유치를 위해 많은 등록 기관이 있으며, ICANN(Internet Corporation for Assigned Names and Numbers)이 이러한 여러 등록기관을 승인해준다. 목록: )

2. 우리는 도메인 네임을 어떤 등록기관에 등록할 때 등록기관에 주책임 서버와 부책임 서버의 이름과 IP주소를 등록기관에 제공해야 한다.
3. 이 두 책임 DNS서버 각각에 대해 등록기관은 Type NS와 Type A 레코드가 TLD com 서버에 등록되도록 확인한다. 특히 주책임 서버의 경우, 등록기관은 다음 2개의 자원레코드를 DNS시스템에 삽입한다. (도메인 네임, 주책임 서버이름, NS), (주책임 서버이름, 주책임 서버의 IP, A)
4. 웹 서버 도메인 이름에 대한 Type A자원 레코드와 메일 서버 도메인 이름에 대한 Type MX 자원 레코드가 우리의 책임 DNS서버에 등록되는 것을 확인해야 한다.(최근에는 DNS프로토콜에 UPDATE 선택 사양이 추가되어 동적으로 추가 혹은 삭제할 수 있다.)

모든 단계가 끝나면 사람들은 우리의 웹사이트를 방문할 수 있고, 우리 회사의 직원들에게 전자메일을 보낼 수 있다.

### DNS취약점

먼저 생각해 볼 수 있는 유형은 DDoS 대역폭 플러딩 공격이다. ICMP 핑메시지를 통해 많은 양의 메시지를 보내면 서버의 지연을 야기시킨다는 것인데, 진작에 ICMP 핑 메시지를 루트 DNS서버로 가는 것을 블록해서 막았다.

DDoS 공격에 좀 더 효과적인 방법으로는 .com과 같은 특정 도메인으로 다량의 DNS 질의를 보내는 것이다. IoT디바이스에 멀웨어를 감염시켜 이들로 구성된 봇넷으로 엄청난 양의 DNS요청을 보냈다.

그 다음으로는 중간자 공격이 있는데, DNS 호스트로 부터 질의를 가로채 가짜 응답 메시지를 보내는 방법이 있다.

이런 공격으로 다른 가짜 사이트로 이동하게끔 유도하는데 지금은 따로 이 공격을 막기 위한 프로토콜이 개발되었다.
