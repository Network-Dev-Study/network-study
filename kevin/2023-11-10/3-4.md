# 신뢰적인 데이터 전송의 원리

신뢰적인 데이터 전송은 링크 계층과 애플리케이션 계층에서도 발생할 수 있는 문제이기 때문에 일반 적인 상황에서의 신뢰적인 데이터 전송문제를 다룬다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394868-aedb95b8-5ff9-4484-a800-aae79619f52f.png)

(A) 제공된 서비스

![Untitled](https://user-images.githubusercontent.com/86337233/211394868-aedb95b8-5ff9-4484-a800-aae79619f52f.png)

(B) 서비스 구현

위의 두 그림은 신뢰적인 데이터 전송 연구의 프레임워크를 보여준다.

상위객체계층에게 제공되는 서비스 추상화는 데이터가 전송될 수 있는 신뢰적인 채널의 서비스 추상화다.

이런 서비스 추상화를 구현하는 것이 신뢰적인 데이터 전송 프로토콜의 의무인데, 신뢰적인 전송 프로토콜의 아래에 있는 계층이 신뢰적이지 않을 수 있어서 어려워진다.

## 신뢰적인 데이터 전송 프로토콜의 구축

유한상태 머신(finite-state machine, FSM)에 대해 먼저 알아보면,

FSM은

- `화살표`는 한 상태로부터 다른 상태로의 전이를 나타낸다.
- FSM의 초기 상태는 `점선 화살표`로 표시된다.
- **전이를 일으키는 이벤트(event)**는 변화를 표기하는 `가로선 위`에 나타낸다.
- 이벤트가 발생했을 때 취해지는 행동, **액션(action)**은 `가로선 아래`에 나타낸다.
- 이벤트 발생 시 어떠한 행동도 취해지지 않거나, 어떠한 이벤트 발생 없이 행동이 취해질 때**동작이나 이벤트가 없음**을 표시하기 위해 각각 가로선 아래나 위에 `기호 𝚲`를 사용한다.

### 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송: rdt1.0

하위 채널이 완전히 신뢰적인 가장 간단한 경우

![Untitled](https://user-images.githubusercontent.com/86337233/211394885-cee89e54-814d-4772-9083-617648a91488.png)

rdt1.0 송신자 수신자에 대한 유한상태 머신(finite-state machine, FSM) 정리이다.

a에서 FSM은 송신자의 동작을 정의하고, b의 FSM은 수신자의 동작을 정의한다.

송신자와 수신자의 분리된 FSM이 있다는 것을 유의해야 한다.

송신자의 수신자의 FSM은 각각 하나의 상태만을 갖고 있다.

rdt의 송신 측은 `rdt_send(data)`의 이벤트에 의해 상위 계층으로부터 데이터를 받아들이고 데이터를 포함한 패킷을 생성한다.

그리고 패킷을 채널로 송신한다.(실제로 `rdt_send(data)`는 상위 계층 애플리케이션의 프로시저 호출에 의해 발생한다.)

수신 측에서 rdt는 `rdt_rcv(packet)` 이벤트에 의해 하위의 채널로부터 패킷을 수신하고

패킷으로부터 `extract(packet, data)`에 의해 데이터를 추출하여

데이터를 상위계층으로 전달한다(`deliver_data(data)`)

rdt_rcv(packet)은 하위 계층 프로토콜로 부터의 프로시저 호출에 의해 발생한다.

여기서 데이터 단위와 패킷의 차이점이 없으며, 모든 패킷 흐름은 송신자로부터 수신자까지다.

수신 측이 송신 측에게 어떤 피드백(feedback)도 제공할 필요가 없다.

또한, 수신자는 송신자가 데이터를 송신하자마자 데이터를 수신할 수 있다고 가정하였다.

따라서 수신자가 송신자에게 천천히 보내라는 것을 요청할 필요가 없다.

### 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송: rdt2.0

비트 오류는 패킷이 전송 또는 전파되거나 버퍼링될 때 네트워크의 물리적 구성요소에서 일반적으로 발생한다.

일반적으로 이런 상황을 다루기위해 컴퓨터 네트워크 설정에서 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜인 자동 재전송 요구(Automatic Repeat reQuest, ARQ) 프로토콜로 알려져 있다.

ARQ에는 세 가지 부가 프로토콜 기능이 요구되어있는데,

1. 오류 검출: 비트 오류가 발생했을 때 수신자가 검출할 수 있는 기능이 필요하다.(앞에서 본 UDP의 체크섬 필드가 그 예시이다.) 현 시점에서는 이런 기술이 송신자로 부터 수신자에게 전송되는 추가적인 비트들이 요구된다.
2. 수신자 피드백: 송신자가 수신자의 상태를 알기 위한 유일한 방법은 수신자가 송신자에게 피드백을 제공하는 것이다. 대표적으로 긍정 확인응답(ACK)과 부정 확인응답(NAK)이 있다. rdt2.0은 수신자가 송신자에게 ACK와 NAK를 전송할 것이다.
3. 재전송: 수신자에게 오류를 가지고 수신된 패킷은 송신자에 의해 재전송된다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394874-2e37ba36-b8c3-454a-aa09-836435f51421.png)

위의 그림에서 오류 검출, 긍정, 부정 확인응답들을 채택하는 데이터 전송 프로토콜 rdt2.0의 FSM을 보여준다.

송신 측은 2개의 상태를 가지게 되는데, 왼쪽 상태의 프로토콜은 상위 계층으로부터 데이터가 전달되기를 기다린다.

`rdt_send(data)` 이벤트가 발생하면, 송신자는 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷(sndpkt)을 생성하여 그 패킷을 `udt_send` 동작을 통해 전송할 것이다.

오른쪽 상태의 프로토콜은 수신자로부터 ACK 또는 NAK패킷을 기다린다.

만약 ACK 패킷이 수신된다면, 송신자는 가장 최근에 전송된 패킷이 정확하게 수신되었음을 알게된다. 그래서 왼쪽 상태로 돌아간다.

하지만 NAK패킷이 수신되었다면, 마지막 패킷(NAK 이전 패킷)을 수신자에게 재전송하고 재전송된 데이터 패킷에 대한 응답으로 수신자에 의해 응답하는 ACK 또는 NAK를 기다린다.(기다리는 동안 상위 계층으로 부터 데이터를 받지 못한다.)

이런 행동은 전송 후 대기 프로토콜로 알려져 있다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394877-619eb70a-cbc0-4e6c-bd47-b29a80d28521.png)

수신 측은 아직까지 단일 상태를 갖는다.

패킷이 도착하면 패킷이 손상되었는 지 확인하기 위해 ACK 또는 NAK로 응답한다.(위의 `rdt_rcv(rcvpkt) && corrupt(rcvpkt)`를 통해 확인할 수 있다.)

rdt2.0이 잘 돌아가는 것 같지만 실제로는 치명적인 결함이 있다.

ACK나 NAK패킷 자체가 손상된다는 가능성을 고려하지 않은 것이다.

이 손상된 패킷을 고치기 위한 3가지 방법들을 고려해 보자.

1. 사람이 응답하는 방식을 생각해보면 답장 중에 ‘뭐라고 하셨죠?’라는 질문을 할 것이다. 이를 이용해 오히려 물어보는 메시지를 보내는 것을 고려해 볼 수 있지만, 이 메시지도 왜곡되면 더 어려운 길로 빠진다.
2. 송신자가 검출하는 것 뿐만 아니라, 비트 오류로부터 회복하기 위한 충분한 체크섬 비트들을 추가하는 것이다. 이 방식은 패킷이 손상될 수 있지만, 손상되지 않으면 즉각적으로 문제를 해결할 수 있다.
3. 송신자가 왜곡된 ACK, NAK패킷을 수신할 때 현재 데이터 패킷을 단순히 다시 송신하는 것이다. 그러나 이 방식은 중복 패킷을 전송하게 하고(다시 받았을 때 수신자에게 ok를 할 것인가?) 근본적으로 다시 돌아오는 패킷이 정확하게 수신되는 지 알 수 없다.

이 문제를 해결하기 위해 패킷의 새로운 필드 안에 순서번호를 삽입하는 방식으로 수신자는 이 패킷이 재전송인지 결정할 때 순서번호만 확인하면 된다.

대기 프로토콜의 경우, 송신자가 이전에 전송된 패킷을 다시 전송할 것인지 아니면 새로운 패킷을 전송할 것인지를 충분히 알 수 있다.

이 순서번호를 가지고 rdt2.0을 수정한 버전이 rdt2.1버전이다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394879-965b1e5e-242d-43a3-a3e5-2981ae49fced.png)

송신자

![Untitled](https://user-images.githubusercontent.com/86337233/211394881-dc92f052-6cc5-44a5-a6ac-716c07f3b6dd.png)

수신자

각각 보면 상태가 전보다 두배 많아졌는데, 이는 패킷 순서번호 0 또는 1을 가져야 하는지를 반영해야 하기 때문이다.

rdt2.1은 수신자로 부터 송신자에게 긍정 확인 응답과 부정 확인 응답을 모두 포함한다.

만약 순서 바뀐 패킷이 수신되면, 수신자는 이미 전에 수신한 패킷에 대한 긍정 확인응답을 전송한다.

손상된 패킷이 수신되면, 수신자는 부정 확인응답을 전송한다.

NAK를 송신하는 것 대신에, 가장 최근에 정확하게 수신된 패킷에 대한 ACK를 송신하며 NAK를 송신한 것과 같은 효과를 얻을 수 있다.

송신자는 수신자가 두번 ACK한 패킷의 다음 패킷을 수신하지 못한 것을 인지한다.

비트 오류를 갖는 채널을 위한 NAK없는 신뢰적인 데이터 전송 프로토콜은 rtd2.2에서 볼 수 있다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394883-973fc4cf-0f42-48e4-a1b5-42d72c818b9f.png)

송신자

![Untitled](https://user-images.githubusercontent.com/86337233/211394888-1ad9f22d-9166-487c-a8aa-f0a380e03cfd.png)

수신자

수신자는 반드시 ACK 메시지에 의해 확인응답되는 패킷의 순서번호를 포함해야하므로 수신자 FSM의 `make_pkt()` 에 ACK, 0 혹은 ACK, 1인 인수를 넣어서 수행한다.

그리고 송신자는 수신된 ACK메시지에 의해 확인응답된 패킷의 순서번호를 반드시 검사해야하므로 `isACK()` 에 0또는 1인 인수를 넣어서 수행한다.

### 비트오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송: rdt3.0

하위 채널이 패킷을 손실하는 경우, 두가지 부가 내용을 프로토콜이 다루어야 한다.

1. 어떻게 패킷 손실을 검출할 것인가
2. 패킷 손실이 발생했을 때 어떤 행동을 할 것인가

후자는 이미 rdt2.2에서 다뤘는데, 전자를 해결하려면 새로운 프로토콜 매커니즘을 추가해야 한다.

여기서 송신자에게 손실된 패킷의 검출과 회복 책임을 부여할 것이다.

만약 송신자가 패킷을 잃어버렸다고 확신할 정도로 충분한 시간을 기다릴 수만 있다면, 데이터 패킷은 간단하게 재전송될 수 있다.

하지만 송신자가 패킷을 손실했다는 것을 확인하기 위해 송신자와 수신자의 왕복 지연에 수신 측에서 패킷을 처리하는 데 필요한 시간을 더한만큼 기다리기 때문에 많은 네트워크에서는 이를 예측하기도 매우 어렵다.

이상적으로는 가능한 빨리 손실을 복구해야 하므로 마냥 기다릴 수 없다.

실제 상황에서는 송신자가 패킷 손실이 일어났다는 보장은 없지만 손실이 일어났을 만한 시간을 선택하는 것이다.(만약 ACK가 일정 시간 내에 수신되지 않는다면 패킷을 재전송한다.)

만약 패킷이 유별나가 큰 지연을 갖는다면 송신자는 패킷을 재전송 할 수 있다.

이는 중복 데이터 패킷의 가능성을 포함하지만 순서번호가 있기 때문에 괜찮다.

송신자에게 재전송은 만병통치약과 같다.

그래서 특정 시간에 재전송하기 위해 카운트다운 타이머를 사용한다.

송신자가 카운트다운 타이머를 사용하는 과정은

1. 매 패킷이 송신된 시간에 타이머를 시작한다.
2. 타이머 인터럽트에 반응한다.
3. 타이머를 멈춘다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394896-6188b35e-abc3-45a4-b3c1-2ad0fbc91738.png)

위의 그림은 송신자의 FSM이고, 아래의 그림은 프로토콜이 패킷 손실 또는 지연 없이 어떻게 동작하는지와 손실된 데이터 패킷을 어떻게 처리하는지 보여준다.

아래의 a번째 그림을 제외하고 나머지 그림의 송신 측 꺾쇠는 타이머가 설정된 후에 타임아웃된 시간을 가리킨다.

패킷의 순서번호가 0과 1이 번갈아 나오므로, 프로토콜 rdt3.0은 때때로 얼터네이팅 비트 프로토콜이라고 부른다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394899-41093893-28a0-4036-99ae-01bb820c7cc9.png)

![Untitled](https://user-images.githubusercontent.com/86337233/211394906-3176a415-2270-493e-92a1-528344a5e00a.png)

![Untitled](https://user-images.githubusercontent.com/86337233/211394858-92791860-cacf-4f94-ab98-f9d7611f337f.png)

![Untitled](https://user-images.githubusercontent.com/86337233/211394848-a1a0d5ce-2190-4bfe-a14f-734a8f23b284.png)

## 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

rdt3.0의 핵심적인 성능 문제는 전송 후 대기 프로토콜이라는 점때문이다.

이 성능을 올바르게 인식하기 위해 아래 그림처럼 하나의 호스트는 미국의 서부에 위치하고 다른 하나는 동부에 있는 종단 호스트들의 경우를 고려하자.

![Untitled](https://user-images.githubusercontent.com/86337233/211394844-59fc6038-cbb8-4df0-823d-3a00bbc12081.png)

전송 후 대기 프로토콜의 동작

![Untitled](https://user-images.githubusercontent.com/86337233/211394855-29852bd1-16df-41bf-94a6-46cbda8a13fa.png)

파이프라이닝된 프로토콜의 동작

여기서 전송 후 대기 프로토콜을 가지고 데이터를 전송한다면 결론적으로 링크를 통해 패킷을 실제로 전송하는데 0.008ms정도 걸리고, 한 패킷 당 다른 호스트로 편도 15ms로 도착했을 때 송신자는 30.008ms 후에 송신자에게 돌아온다.

송신자는 30.008ms동안 0.008ms만 일하기 때문에 형편없는 송신자 이용률(0.027%)을 가진다.

호스트가 하위계층에서 초당 1Gbps의 링크가 가용하다고 해도 최대 267kbps밖에 처리하지 못한다. 이것은 네트워크 프로토콜들이 어떻게 하위 네트워크 하드웨어가 제공하는 용량을 제한할 수 있는지 보여주는 예시이다.(심지어 중간에 일어날 지연은 무시한 수치다.)

이를 해결하기 위해 그냥 확인 응답을 받지 않고 계속 여러 패킷을 보내는 것이다.

패킷이 왔다갔다하는 시간동안 추가적으로 n개의 패킷을 보낸다면, 그만큼 이용률도 n+1배만큼 증가한다.

이를 파이프라이닝이라 부른다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394842-0a9b9db2-f2a5-4668-b5e8-bc8d634c323e.png)

![Untitled](https://user-images.githubusercontent.com/86337233/211394851-46a5b475-2554-47f4-b33e-5699f909e4cb.png)

파이프라이닝은 다음과 같은 중요성을 지니고 있다.

- 순서번호의 범위가 커져야 한다. 각각의 전송 중인 패킷은 유일한 순서번호를 가져야 하고 전송 중인 확인응답이 안된 패킷이 여러 개 있을 지도 모르기 때문이다.
- 프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야 한다. 최소한 송신자는 전송되었으나 확인응답되지 않은 패킷을 버퍼링해야한다. 정확하게 수신된 패킷의 버퍼링은 다음에 설명한 것처럼 수신자에게서도 필요하다.
- 필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 응답하는 방식에 달려있다. 두가지 기본적인 접근 방법으로 GBN(Go-Back-N, N부터 반복)과 SR(Selective Repeat, 선택적 반복) 이 있다.

## GBN

송신자는 확인응답을 기다리지 않고 여러 패킷을 전송 할 수 있다.

그러나 파이프라인에서 확인응답이 안된 패킷의 최대 허용 수 N보다 크지 말아야 한다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394862-a28b3bd5-60b4-45b9-b16a-db23e1718476.png)

위의 그림은 GBN 프로토콜에서 송신자 관점의 순서 번호 범위를 보여준다.

확인응답이 안된 가장 오래된 패킷의 순서번호를 base로 정의하고 사용되지 않은 가장 작은 순서 번호를 nextseqnum으로 정의한다면 순서 번호의 범위에서 4개의 간격을 식별할 수 있다.

간격 [0, base-1]에서 순서 번호는 이미 전송되고 확인응답이 된 패킷에 대응된다.

간격 [base, nextseqnum-1]은 송신은 되었지만 아직 확인응답이 되지 않은 패킷에 대응된다.

간격 [nextseqnum, base+N-1]은 상위 계층으로부터 데이터가 도착하면 바로 전송될 수 있는 패킷을 위해 사용될 수 있다.

마지막으로 base+N이상의 순서 번호는 파이프라인에서 확인응답이 안된 패킷의 확인응답이 도착할 때까지 사용될 수 없다.

여기서 윈도 사이즈 N은 아직 확인응답이 안된 패킷을 위해 허용할 수 있는 순서 번호의 범위이다.

이 윈도는 순서 번호 공간에서 오른쪽으로 이동된다.

GBN프로토콜은 이런 점으로 슬라이딩 윈도 프로토콜이라고 부른다.

왜 굳이 N을 정하는 이유는 나중에 혼잡 제어에서 살펴볼 수 있다.

실제로 패킷의 순서 번호는 패킷 헤더 안의 고정된 길이 필드에 포함된다.

만약 k가 패킷 순서 번호 필드의 비트 수라면, 순서 번호의 범위는 [0, 2^k-1]이 된다.

순서 번호의 제한된 범위에서, 순서 번호를 포함하는 모든 계산은 모듈로 2^k연산을 이용한다.

3.5절의 TCP는 32비트 순서 번호 필드를 갖는다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394871-a9808254-013c-4858-b27c-6830d9602384.png)

송신자

![Untitled](https://user-images.githubusercontent.com/86337233/211394884-f585ef99-e84a-4b88-a268-794e31d1ad38.png)

수신자

위의 두 그림은 ACK기반의 NAK없는 GBN프로토콜의 송신 측과 수신 측의 확장된 FSM을 보여준다.

여기서 base와 nextseqnum변수를 추가했고, 이 변수들을 기반으로 조건부 동작들을 추가했으므로 확장된 FSM을 보여준다.

GBN 송신자는 3가지 타입의 이벤트에 반응해야 한다.

1. 상위로부터의 호출: rdt_send()가 위로부터 호출되면, 송신자는 우선 윈도가 가득 찼는지 확인한다.

   만약 윈도가 가득 차 있지 않다면, 패킷이 생성되고 송신하며 변수들이 적절하게 갱신된다.

   하지만 윈도가 가득 차 있다면, 송신자는 윈도가 가득 차 있음을 가리키는 함축적인 의미로 단지 데이터를 상위 계층으로 반환한다.

   실제 구현에서 송신자는 이 데이터를 버퍼링하거나 오직 윈도가 가득 차 있지 않을 때만 rdt_send()를 호출하는 동기화 메커니즘을 사용할 것이다.

2. ACK의 수신: GBN프로토콜에서 순서 번호 n을 가진 패킷에 대한 확인응답은 누적 확인응답으로 인식된다. 이 누적 확인응답은 수신 측에서 올바르게 수신된 n을 포함하여 n까지의 순서 번호를 가진 모든 패킷에 대한 확인 응답이다.

3. 타임아웃 이벤트: 전송 후 대기 프로토콜에서와 같이, 타이머는 손실된 데이터 또는 손실된 확인응답 패킷으로부터 회복하는데 사용된다.

   만약 타임아웃이 발생하면, 송신자는 이전에 전송되었지만 아직 확인응답되지 않은 모든 패킷을 다시 송신한다. 아래 그림에서 단일 타이머를 사용한다.

   만약 추가로 전송했는데 아직 확인응답 안된 패킷이 존재한다면, 타이머는 다시 시작된다. 확인응답안된 패킷이 없다면 타이머는 멈춘다.

수신자의 행동도 단순하다. 만약 순서번호 n을 가진 오류 없이 순서대로 수신된다면, 수신자는 패킷 n에 대한 ACK를 송신하고 상위 계층에 패킷의 데이터 부분을 전달한다.

그 외에는 그 패킷을 버리고 가장 최근에 제대로 받은 순서의 패킷에 대한 ACK를 재전송한다.

k번째 패킷에 있는 데이터를 상위 계층으로 보냈다면 이미 k번째 까지는 제대로 전달된 것이다.

따라서, 누적 확인응답을 사용하는 것은 GBN에게 자연스러운 선택이다.

GBN프로토콜에서는 순서가 잘못된 패킷들을 버린다. 낭비같지만, 몇가지 당연한 이유들이 있다.

n번째 패킷을 받지 않고 n+1번째 패킷을 받아 버리지 않고 가지고 있는데 n번째 패킷이 손실되어 있다면, GBN재전송 규칙에 따라 패킷 n과 n+1 모두 재전송 될 것이다.

장점은 굳이 버퍼링할 필요가 없다는 것이다.

그리고 송신자는 윈도 상위와 하위 경계, 윈도 안에 있는 nextseqnum을 유지해야하고, 수신자는 다음 순서 패킷의 순서번호만 유지하면 된다.

물론, 올바르게 수신된 패킷을 버리는 것의 단점은 그 패킷의 재전송이 손실되거나 왜곡될 수 있으므로 많은 재전송이 필요할 수 있다.

아래의 그림은 윈도 크기가 4패킷인 경우에 대한 GBN 프로토콜의 동작을 보여준다.

ACK가 수신될 때마다 윈도는 앞으로 이동하고 송신자는 새로운 패킷을 전송한다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394894-0ebcca6d-1174-446b-a2c4-e74ca263ab63.png)

확장된 FSM에서 이 구현은 발생할 수 있는 다양한 이벤트에 대한 대응으로 취할 수 있는 동작을 구현하는 다양한 절차들과 유사하다.

이를 이벤트 기반 프로그래밍이라 하고, 이 이벤트 기반 프로그래밍에서의 다양한 프로시저들은 프로토콜 스택에서 다른 프로시저에 의해 야기되거나 인터럽트의 결과로 요청될 것이다.

송신자에서 이런 이벤트는

1. rdt_send()를 호출하기 위한 상위 계층 개체로부터의 호출
2. 타이머 인터럽트
3. 패킷이 도착했을 때 rdt_rcv()를 호출하기 위한 하위 계층으로부터의 호출이다.

GBN프로토콜은 TCP의 신뢰적인 데이터 전송 구성요소를 다룰 때 거의 모든 기술이 통합되어 있음에 유의해라.

## SR

GBN자체에도 성능문제들을 겪는 시나리오들이 존재한다.

특히 윈도 크기와 대역폭 지연 곱의 결과가 모두 클 때, 많은 패킷이 파이프라인에 있을 수 있다.

그리고 하나의 패킷이 오류가 났다고 많은 패킷을 재전송하므로, 많은 패킷들을 불필요하게 재전송하는 경우가 발생한다.

채널 오류의 확률이 증가할수록 파이프라인은 불필요한 재전송 데이터로 채워진다.

SR(Selective Repeat, 선택적 반복) 프로토콜은 수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송하므로 불필요한 재전송을 피한다.

필요에 따라 올바르게 수신된 패킷에 대한 개별적인 확인응답을 요구할 것이다.

아래 그림을 보면 SR의 송신자와 수신자의 관점을 볼 수 있다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394904-44a6f9a3-d889-487b-b88f-dbeb04e73e59.png)

추가로 송신자와 수신자의 이벤트와 행동은 다음과 같다.

송신자

1. 상위로부터 데이터 수신: SR송신자는 패킷의 다음 순서 번호를 검사한다.

   순서번호가 윈도 내에 있으면 데이터는 패킷으로 송신된다.

   아니면 나중에 전송하기 위해 상위 계층으로 보낸다.

2. 타임아웃: 타이머는 손실된 패킷을 보호하기 위해 재사용된다.

   타임아웃 시 오직 한 패킷만이 전송되기 때문에 각 패킷은 자신의 논리 타이머가 있어야 한다.

   하나의 하드웨어 타이머가 여러개의 논리 타이머를 흉내내는데 사용된다.

3. ACK수신: ACK가 윈도 내에 있으면 그 패킷을 수신된 것으로 표기한다.

   만약 순서 번호가 send_base와 같다면, 윈도 베이스는 가장 작은 순서 번호를 가진 아직 확인 응답되지 않은 패킷으로 옮겨진다.

   만약 윈도가 이동되었는데, 아직 윈도 내에 순서 번호를 가진 미전송 패킷이 있다면 이 패킷들은 재전송된다.

수신자

1. [rcv_base, rcv_base+N-1] 내의 순서 번호를 가진 패킷이 손상 없이 수신된다: 이 경우는 수신된 패킷이 수신자의 윈도에 속하는 것이며, 선택적인 ACK 패킷이 송신자에게 회신된다.

   앞에 손실되어 받지 못한 패킷이 있는 경우, 상위계층으로 먼저온 번호가 높은 패킷들을 보내지 않고 손실된 패킷을 받았을 때, 상위 계층으로 보낸다.(아래 그림 참고)

2. [rcv_base-N, rcv_base-1]내의 순서 번호를 가진 패킷이 수신된다: 이 경우 이 패킷이 수신자가 이전에 확인 응답한 것이라도 ACK가 생성되어야 한다.
3. 그 이외: 패킷을 무시한다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394908-f90e0b68-e305-486a-94b4-20ce10469130.png)

수신자 관점에서 현재의 윈도 base보다 낮은 특정 순서 번호를 가진 이미 수신된 패킷을 무시하지 않고 재확인 응답을 하는 것이 중요하다.(ACK가 없기 때문이다)

이를 수행하지 않는다면 송신 측의 윈도는 앞으로 나아가지 못한다.

송신자와 수신자의 윈도는 항상 같은 관점을 가지지 않으므로 같지 않다.

송신자와 수신자 윈도 사이의 동기화 부족은 아래 그림처럼 순서 번호의 한정된 범위에 직면했을 때 중대한 결과를 가져온다.

![Untitled](https://user-images.githubusercontent.com/86337233/211394834-3ca59693-1674-474f-b726-92b6b4db0f61.png)

![Untitled](https://user-images.githubusercontent.com/86337233/211394820-f3805860-5058-49e5-8e01-c63729a33699.png)

두 시나라오 모두 다섯 번째 패킷의 원래 전송과 첫 번째 패킷의 재전송을 구별할 방법은 없다.

순서 번호 공간 크기보다 1이 작은 윈도 크기에서 동작하지 않는다.

그렇다면 최소한의 윈도 크기는 얼마나 될까?

순서 번호 공간 크기보다 절반이하여야 함을 보여야 한다.

우리는 송신자와 수신자 사이에 순서가 바뀔 수 없다고 가정했지만, 모종의 이유로 순서가 바뀔 수 있다.

그래서 송신자와 수신자 측에서 윈도가 x를 포함하지 않고 있더라도 순서 번호 또는 확인응답 번호 x를 가진 오래된 패킷의 복사본들이 생길 수 있다.

결국 순서 번호가 재사용 될 수 있으므로 그런 중복된 패킷들을 막을 수 있는 조치가 있어야 한다.

실제로는 송신자가 이전에 송신된 순서 번호 x를 가진 패킷들이 더는 네트워크 상에 없음을 어느정도 확신 할 때 까지 순서 번호가 재사용되지 않음을 확실히 하는 것이다.

이는 패킷이 일정 시간 이상으로 네트워크에서 존재할 수 없다는 가정으로 이루어 진다.

### 요약(다른 사람 깃허브 저장소에서 가져옴)

### 체크섬

전송된 패킷 안의 **비트 오류**를 발견하는 데 사용된다.

### 타이머

채널 안에서 패킷이 손실되었기 때문에 발생되는 패킷(또는 이것의 ACK)의 **타임아웃/재전송**에 사용된다.

### 타임아웃

발생 이유

1. 패킷이 지연되었지만 손실되지는 않았을 경우 (`조기 타임 아웃`)
2. 패킷이 수신자에 의해 수신되었으나 수신자에서 송신자로의 `ACK가 손실`되었을 경우

→ 수신자에 의해 수신되는 패킷은 중복으로 복사(수신)된 패킷일 수 있다.

### 순서 번호

송신자에서 수신자로 가는 데이터 패킷의 순서 번호를 붙이기 위해 사용된다.

- `수신자 패킷의 순서 번호의 간격` : 수신자가 손실된 패킷을 검사하게 한다.
- `중복된 순서 번호를 갖는 패킷` : 수신자가 패킷의 중복 복사를 검사하게 한다.

### 확인응답

수신자가 한 패킷 또는 패킷 집합이 **정확히 수신되었다는 응답**을 송신자에게 하기 위해 사용된다.

- 일반적으로 패킷 또는 이미 확인응답된 패킷들의 순서 번호를 전달한다.
- 프로토콜에 따라 개별적이거나 누적된 것일 수 있다.

### 부정 확인응답

수신자가 패킷이 **정확히 수신되지 않았다는 응답**을 송신자에게 하기 위해 사용된다.

- 일반적으로 정확히 수신되지 않은 패킷의 순서 번호를 전달한다.

### 윈도, 파이프라이닝

송신자는 **주어진 범위에 있는 순서 번호를 가진 패킷만 전송하도록 제한**될 수 있다.

확인응답은 없지만 허가된 패킷이 전송될 수 있으므로, 송신자의 이용률은 전송 후 대기 모드의 동작보다 증가할 수 있다.

`윈도 크기`는 수신자의 메시지를 수신하고 버퍼링하는 능력, 네트워크의 혼잡 정도, 또는 두 가지 모두에 근거하여 설정된다.
