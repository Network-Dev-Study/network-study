# 라우팅 알고리즘

라우팅 알고리즘의 목표는 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것이다.

라우팅 문제를 나타내는 데는 그래프가 사용된다.

![Untitled](https://user-images.githubusercontent.com/86337233/213212557-7f4721cc-104d-4102-9c13-b4d45e4ae79d.png)

G(N, E)에서

N은 노드의 집합이다.

네트워크 계층 라우팅 상황에서 그래프상의 노드는 패킷 전달이 이루어지는 라우터를 의미한다.

E는 에지의 집합이다.

에지의 값은 물리적인 거리, 링크 속도, 링크와 관련된 금전적인 비용 등을 반영한다.

집합 E안에 포함된 어떤 에지(x, y)에 대해 c(x, y)는 노드 x와 y간의 비용을 의미한다.

만약 c(x, y)가 E안에 포함되어 있지 않다면 c(x, y)=(inf)가 된다.

또한 무방향성 그래프만을 고려한다.

에지 (x, y)가 집합 E에 속한다면 y는 x의 이웃이라 한다.

그래프 G(N, E)에서의 경로는 노드의 연속`(x1, x2, x3, …, xp)`이고,

노드 쌍 `(x1, x2), (x2, x3), … , (xp-1, xp)`는 집합 E에 속한 에지들이다.

경로 `(x1, x2, x3, … , xp)`의 비용은 경로상 모든 에지 비용의 단순 합이다.

`c(x1, x2) + c(x2, x3) + … + c(xp-1, xp)`

라우팅 알고리즘을 분류하는 일반적인 방법 한 가지는 알고리즘이 중앙 집중형인지 분산형인지다.

- 중앙 집중형 라우팅 알고리즘
  네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다.
  이런 정보는 알고리즘이 실제 계산을 수행하기 전에 어떤 방법을 통해서라도 알아야 한다.
  이렇게 전체 상태 정보를 갖는 알고리즘을 링크 상태(LS) 알고리즘이라 한다.
- 분산 라우팅 알고리즘
  최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다.
  어떤 노드도 완전한 정보를 가지고 있지 않지만 각 노드는 자신에게 직접 연결된 링크에 대한 비용 정보만을 가지고 시작한다.
  이런 알고리즘은 거리 벡터(DV) 알고리즘이라 한다.

두번째는 정적인지 동적인지 구분하는 것이다.

- 정적 라우팅 알고리즘
  보통 사람이 개입해 수정하기 때문에 경로가 아주 느리게 변화한다.
- 동적 라우팅 알고리즘
  네트워크 트래픽 부하나 토폴로지 변화에 따라 라우팅 경로를 바꾼다.
  변화에 빠르다는 장점이 있지만, 경로의 루프나 경로 진동 같은 문제에 취약하다.

세 번째는 라우팅 알고리즘이 부하에 민감한지 아닌지에 따른다.

민감하다면 링크 비용은 해당 링크의 현재 혼잡 수준을 나타내기 위해 동적으로 변한다.(해당 라우터가 혼잡하다면 일부러 높은 비용을 부과해 버린다.)

하지만 오늘날은 링크 비용이 현재의 혼잡을 반영하지 않기 떄문에 부하에 민감하지 않다.

## 링크 상태 라우팅 알고리즘

해당 알고리즘은 네트워크 토폴로지와 모든 링크 비용이 알려져 있어 링크 상태 알고리즘의 입력값으로 사용될 수 있다.

이는 각 노드가 자신과 직접 연결된 링크의 식별자와

비용 정보를 담은 링크 상태 패킷을

네트워크 상의 다른 모든 노드로 브로드 캐스트하게 함으로써 가능하다.

이는 링크 상태 브로드캐스트 알고리즘에 의해 수행된다.

이링크 상태 알고리즘은 다익스트라 알고리즘이라 부른다.

다익스트라 알고리즘은 하나의 노드에서 네트워크 내 다른 모든 노드로의 최소 비용 경로를 계산한다.

다익스트라 알고리즘은 반복적이고, 알고리즘의 k번째 반복 이후에는 k개의 복적지 노드에 대해

최소 비용 경로가 알려지며 이 k개의 경로는 모든 목적지 노드로의 최소 비용 경로 중에서 가장 낮은 비용을 갖는 k개의 경로다.

아래는 다음과 같이 기호들을 정의한다.

- D(v): 현재 반복 시점에서 출발지 노드부터 목적지 v까지의 최소 비용 경로의 비용
- p(v): 출발지에서 v까지의 현재 최소 비용 경로에서 v의 직전 노드
- N’: 노드의 집합이고 출발지에서 v까지의 최소 비용 경로가 명확히 알려져 있다면, v는 N’에 포함된다.

알고리즘은 초기화와 반복 단계로 구성되어 있다.

### 출발지 노드 u를 위한 링크 상태 알고리즘

![Untitled](https://user-images.githubusercontent.com/86337233/213212565-e58f1ba9-0003-4caf-8a94-dd836d0a7dad.png)

이 코드를 아래 그래프에 적용시키면 다음과 같다.

![Untitled](https://user-images.githubusercontent.com/86337233/213212557-7f4721cc-104d-4102-9c13-b4d45e4ae79d.png)

![Untitled](https://user-images.githubusercontent.com/86337233/213212575-f2a19606-b0c5-4b5b-b5cf-d7dc806ede6d.png)

링크 상태 알고리즘이 종료된 후에 우리는 각 노드에 대해 출발지 노드로부터의 최소 비용 경로상의 직전 노드를 알게 된다.

노드 u의 포워딩 테이블은 각 목적지에 대해 / 노드 u에서 그 목적지까지의 최소 비용 경로상의 다음 홉 노드 정보를 저장하여 구성한다.

아래 그림은 최소 비용 경로의 결과와 노드 u의 포워딩 테이블을 보여준다.

![Untitled](https://user-images.githubusercontent.com/86337233/213212579-440664b4-0be5-4e54-bca0-023029c6f39c.png)

그렇다면 이 알고리즘의 복잡도는 얼마일까?

n개의 노드가 있고, 최악의 경우를 봤을 때,

1. N’에 포함되지 않은 노드 w를 결정하기 위해 n개의 노드를 검사한다.
2. 두 번째에서는 n-1개의 노드를 검사해야하고
3. 세 번째에서는 이런 규칙으로 n-2개의 노드를 검사해야 한다.

- 부록: 우선순위 큐로 검사한다면
  V개의 노드와 E개의 간선이 있다면
  `O((V+E)logV)` 된다.
  1. 우선순위 큐에서 노드 V와 노드에 연결된 간선의 개수 E만큼 확인한다.(E+V)
  2. 우선순위 큐에서 간선을 넣고 빼는 과정이 logE만큼 걸린다.
  3. 모든 간선을 우선순위 큐에 넣고 뺀다면 `O((E+V)logE)`만큼의 복잡도를 가진다.
  4. 이때 간선이 중복되지 않는다면 E는 항상 V^2 이하이다.(최악의 경우 E는 V^2만큼 클 수 있다.)
  5. 그래서 E를 V^2으로 대입하면 `O((E+V)logV)`혹은 `O(V^2logV)`가 나온다.

찾아야 하는 노드의 총 수는 n(n+1)/2이고, 이는 O(n^2)의 복잡도를 가진다.

이 알고리즘에서 진동 문제가 발생할 수 있다.

아래 그림은 단순한 네트워크 토폴로지로서 링크 비용은 링크를 통과하는 트래픽 부하와 같고, 이는 패킷이 겪을 수 있는 지연 시간을 반영한다.

![Untitled](https://user-images.githubusercontent.com/86337233/213212582-bad1ee34-70c9-4ec3-babd-1240b362fd9d.png)

처음에 y에서 w로 가는 최소 비용 경로는 시계방향이다.

그리고 x도 w로 가는 최소 비용 경로로 시계방향을 설정한다.

![Untitled](https://user-images.githubusercontent.com/86337233/213212586-a123652a-3701-44a0-b822-1801901397d4.png)

여기서 w로 가는 반시계 방향의 경로 비용이 0임을 알게되어 반시계방향으로 경로를 보낸다.

![Untitled](https://user-images.githubusercontent.com/86337233/213212593-8b7fcd6f-ee6b-4118-ab94-e1f995c93b22.png)

다음에는 시계방향으로 경로를 보낸다.

![Untitled](https://user-images.githubusercontent.com/86337233/213212599-fb4216f6-277b-491e-ac4c-455f0a6cf810.png)

이런 진동 문제를 방지하기 위한 방법 중 하나로는

모든 라우터가 동시에 링크 상태 알고리즘을 실행하지 못하도록 하면 된다.

라우터들이 동일한 주기 간격으로 링크 상태 알고리즘을 수행한다 하더라도

각 노드에서의 알고리즘의 실행 시각은 같지 않을 것이기 때문에 합리적인 방법이라고 생각된다.

하지만 연구자들은 라우터들이 알고리즘을 처음에는

각기 다른 시작 시각에, 그러나 같은 주기를 갖도록 해서 실행하더라도

점진적으로 결국엔 서로 동기화된다는 것을 발견하였다.

이러한 자기 동기화는 각 노드가 링크 상태 정보를 송신하는 시각을 임의로 결정하게 함으로써 회피할 수 있다.
