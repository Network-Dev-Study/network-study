# 거리벡터 알고리즘

반복적이고 비동기적이며 분산적이다.

벨만-포드 식에 의해 최소 비용 경로의 비용(dx(y))은 다음과 같다.

참고로 minv는 노드 x의 모든 이웃에 적용되고, x에서 y까지 이동하는데

v를 거쳐간다고 가정하므로 최소 비용은 x와 x의 이웃노드의 비용, v와 y 간의 최소 비용을 더한 합의 최솟값이 된다.

`dx(y) = minv{c(x, v) + dv(y)}`

벨만-포드 식의 실질적 공헌 중 하나는 거리벡터 알고리즘에서 알어나는 이웃 간 통신 형식을 제안하는 점이다.

### 거리 벡터 알고리즘

![Untitled](https://user-images.githubusercontent.com/86337233/213212614-4c524d17-1dbb-4518-b7b0-7014fa6f4413.png)

DV 알고리즘에서 하나의 노드가 갖는 정보는 단지 자신에게 직접 연결된 이웃으로의 링크 비용과 그 이웃들로부터 수신하는 정보뿐이다.

1. 각 노드는 이웃으로부터의 갱신을 기다리고 (10~11번째 줄)
2. 업데이터를 수신하면 새로 거리 벡터를 계산하고 (14번째 줄)
3. 이 새로운 거리 벡터를 이웃들에게 배포한다. (16~17번째 줄)

이 과정은 더 이상의 갱신 메시지가 없을 때까지 계속 되며,

갱신 메시지가 없으면 알고리즘은 정지 상태가 된다.

즉, 링크 비용이 변할 때까지 정지 상태로 있는다.

![Untitled](https://user-images.githubusercontent.com/86337233/213214084-e5a9f23c-f149-48b1-ad74-a19155d6dcbf.png)

위 그림은 거리 벡터 알고리즘의 동작을 나타내는데, 동기적으로 보이겠지만, 비동기적으로도 올바르게 동작할 수 있다.

### 링크 비용 변경과 링크 고장

최소 비용 경로의 비용이 감소한 상황과 증가한 상황 두 가지를 살펴보자.

비용이 감소한 경우

![Untitled](https://user-images.githubusercontent.com/86337233/213214090-baa35d20-b8c1-495e-b82d-c877001f6737.png)

1.  `y`가 링크 비용의 변화를 감지하고, 자신의 거리 벡터를 갱신한 후 이 변경값을 이웃에게 알린다.
2.  `z`는 `y`로부터 갱신 정보를 받고 자신의 테이블을 갱신한다.

    `z`는 `x`까지의 새로운 최소 비용을 계산한다.

    이웃에게 자신의 새로운 거리 벡터를 전송한다.

3.  `y`는 `z`로부터 갱신 정보를 받고 자신의 테이블을 갱신한다.

    y의 최소 비용은 변화가 없으므로 y는 z에게 아무런 메시지를 보내지 않는다.

    알고리즘은 정지 상태가 된다.

이 상황에서는 정지 상태가 될 때까지 두 번만 반복하면 된다.

비용이 증가한 경우

![Untitled](https://user-images.githubusercontent.com/86337233/213214092-9b56f797-4182-43fa-baff-98f56be140a8.png)

이 상황에서의 DV 알고리즘은 다음과 같은 일련의 사건을 발생시킨다.

1. `y`가 링크 비용 변화를 감지하고 노드 `x`까지 다음의 비용을 갖는 새로운 최소 비용 경로를 계산한다.

   ![](https://user-images.githubusercontent.com/86337233/213214096-1af1855b-1116-49ac-8873-1943c7727dc5.png)

   이때 우리는 네트워크 전체를 한눈에 볼 수 있기 때문에 `z`를 경유하는 이 새로운 비용이 **잘못되었다**는 사실을 알 수 있지만,노드 `y`의 입장에서는 아니다.

2. `x`로 가기 위해 `y`는 `z`로 경로 설정을 하고, `z`는 `y`로 경로 설정을 하는 `라우팅 루프(routing loop)`가 발생한다.

   `x`를 목적지로 하는 패킷이 `y`나 `z`에 도착하면 포워딩 테이블이 변할 때까지 이 두 노드 사이에서 왔다 갔다 순환할 것이다.

   노드 `y`는 `x`까지의 새로운 최소 비용을 계산했으므로 `z`에게 새로운 거리 벡터를 알린다.

3. `z`는 `y`로부터 갱신 정보를 받고 새로운 최소 비용을 계산한다.

   `D.z(x) = min{50+0, 1+6} = 7`

   `x`까지의 `z`의 최소 비용이 증가했으므로, 새로운 거리 벡터를 `y`에 알린다.

4. `y`는 `z`로부터 새로운 거리 벡터를 수신하고 새로운 최소 비용을 계산한다.

   `Dy(x) = min{60+0, 1+7} = 8`

   `x`까지의 `y`의 최소 비용이 증가했으므로, 새로운 거리 벡터를 `z`에 알린다.

5. …

이렇게 계속 반복되는 문제를 `무한 계수 문제(count-to-infinity)`라고 한다.

### 포이즌 리버스 추가

위와 같은 문제는 `포이즌 리버스`를 사용해 방지할 수 있다.

만약 z가 y를 통해 목적지 x로 가는 경로 설정을 했다면, z는 y에게 x까지의 거리가 무한대라고 알린다.

z는 y를 통과해서 x로 가는 동안 이런 거짓말을 계속한다.

y는 z에서 x로 가는 경로가 없어졌다고 믿으므로 y는 z를 통해 x로가는 경로를 시도하지 않을 것이다.

하지만 3개 이상의 노드를 포함한 루프는 포이즌 리버스로는 감자할 수 없다.

### 링크 상태 알고리즘과 거리 벡터 알고리즘의 비교

- 메시지 복잡성
  링크 상태에서는 O(N\*E)개의 메시지를 전송해야한다.
  링크 비용이 변할 때마다 새로운 링크 비용이 모든 노드에게 전달되어야 한다.
  거리 벡터 에서는 직접 연결된 이웃끼리 메시지를 교환한다.
  새로운 링크 비용이 이 링크에 연결된 어떤 노드의 최소 비용 경로에 변화를 준 경우에만 수정된 링크 비용을 전파한다.
- 수렴 속도
  링크 상태는 O(N\*E)개의 메시지를 필요로 하는 O(n^2)알고리즘이다.
  거리 벡터는 천천히 수렴하고 알고리즘이 수렴하는 동안 라우팅 루프와 무한계수 문제가 발생할 수 있다.
- 견고성
  링크 상태에서는 연결된 링크에 대해 잘못된 비용 정보를 브로드캐스트할 수 있다.
  그리고 링크 상태 브로드캐스트를 통해 받은 패킷을 변질시키거나 폐기할 수 있다.
  그러나 하나의 링크 상태 노드는 자신의 포워딩 테이블만 계산하기 때문에 링크 상태 알고리즘에서 경로 계산은 어느 정도 분산되어 수행된다.
  따라서 링크 상태 알고리즘은 어느 정도의 견고성을 제공한다.
  거리 벡터는 잘못된 최소 비용 경로를 일부 혹은 모든 목적지에 알릴 수 있다.
  각 반복마다 한 노드의 거리 벡터 계산이 이웃에게 전달되고 다음 반복에서 이웃의 이웃에게 간접적으로 전달된다.
  따라서 거리 벡터 알고리즘을 사용하는 네트워크에서 한 노드의 잘못된 계산은 전체로 확산될 수 있다.
  실제로 1997년에 작은 ISP에서 오작동한 라우터가 잘못된 라우팅 정보를 전국망의 백본 라우터에 제공한 적이 있었다.
  이는 다른 라우터들이 오작동한 라우터에게 대규모 트래픽을 보내게 만들었고,
  인터넷의 상당 부분이 여러 시간 동안 단절되었다고 한다.

결국 어떤 알고리즘이 다른 알고리즘보다 명백히 낫다고 말할 수는 없으며,

실제로 두 알고리즘 모두는 인터넷에서 사용되고 있다.
