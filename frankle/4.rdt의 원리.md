# rdt란

TCP는 UDP에 비해 다양한 기능들을 제공하는데, 그 중 하나가 **신뢰성 있는 데이터 전달(reliable-data-transfer)**이다.

이번 챕터에서는 이 rdt에 대한 원리에 대해 살펴본다.

프로세스 간 통신 과정에서 전송 계층의 하위 계층에서 패킷 전달 도중 패킷 손상, 패킷 로스 등 네트워크 문제가 발생할 가능성이 있으므로 데이터 전달에 대한 신뢰성을 보장할 수 없다.

이전에 살펴보았던 네트워크 계층의 IP 프로토콜 또한 목적지에 패킷을 전달하기 위해 최선을 다할 뿐이지 도착을 보장한다고 하진 않았다.

즉 rdt의 배경은 전송 계층 하위 계층에서의 불안전한 데이터 전달을 신뢰성있는 데이터 전달로 보장하도록 보완하기 위한 전송 계층의 프로토콜이다.

rdt의 단순 개념은 송신자의 메시지가 수신자가 정상적으로 받았음을 확인한 뒤 이후 메시지를 보내는 것이다.

# rdt 버전별 설명

## rdt 1.0

rdt 1.0은 하위 계층이 위 두 문제를 발생시키지 않고 완전히 신뢰성 있는 데이터 통신을 보장하는 환경으로 가정한다.

즉, rdt 1.0은 송신자가 메시지를 보내면 수신자는 무조건 온전히 수신한다고 본다.

## rdt 2.0

rdt 2.0은 패킷 손실은 배제하고 패킷 손상에 대해서만 고려한다.

패킷 손상은 전화 통화를 예로 들 수 있는데, 서로 얼굴을 맞대고 있지 않은 상황에서 유선상 통화 시 전화를 건 사람이 무언가 말을 했고, 전화를 받은 사람이 제대로 이해했다면 긍정적인 응답하고, 제대로 이해하지 못했다면 부정적인 응답을 한다.

정상 수신은 ACK(acknowledgements), 비정상 수신은 NAK(negative acknowledgements)를 의미한다.

송신자가 보낸 메시지를 수신자가 받아 헤더의 체크섬 정보를 통해 오류를 검출하고 문제가 있으면 NAK, 에러가 없으면 ACK를 송신자에게 피드백을 반환한다. 송신자는 피드백인 ACK를 받으면 다음 메시지, NAK를 받으면 이전에 했던 메시지를 재송신한다.

### rdt 2.0의 결점

ACK, NAK 또한 패킷이기에 에러가 발생할 수 있는데, 이는 송신자 입장에서 보낸 메시지에 대한 피드백이 손상될 수 있다는 의미이다.  rdt 2.0에서 해당 문제에 대해서 고려되지 않았다.

위 문제를 해결하기 위해 재전송을 생각할 수 있는데, 이는 문제가 있다.

송신자가 메시지를 보내고 수신자는 제대로 받아 ACK를 응답하는데 도중에 손상되어 송신자가 받았다면, 이전에 보낸 메시지를 재송신할 수도 있다.

수신자 입장에서 ACK를 보냈었으니 새로 들어오는 메시지에 오류가 없다면 정상인 다음 메시지로 판단하게 될수도 있고 이는 잘못된 상황이다. 메시지가 재송신된 메시지인지 새로운 메시지인지 판단하기 어려워지게 되는 것이다.

## rdt 2.1

문제를 해결하기 위해 보내는 패킷과 헤더 필드에 Sequence Number란 순번을 담아 보낸다. 시퀀스 번호 0 또는 1인 1 bit로 이뤄지고, 이를 통해 수신자는 받은 메시지가 새로운 메시지인지 중복된 메시지 판단할 수 있다.

A(0)B(1)C(0)D(1)란 메시지가 있다고 가정했을 때, 송신자는 A(0)을 보내고 수신자는 A(0)을 정상적으로 받고 ACK를 넘긴 뒤 다음 시퀀스 넘버인 1에 대한 패킷을 기다린다.

아까와 동일한 상황이 발생해 송신자가 A(0)을 재송신한다고 하더라도 이제는 수신자가 새로운 메시지인지 중복 메시지인지 판가름할 수 있는 것이다.

수신자는 중복 패킷을 받으면 패킷을 버리되 에러 여부에 따라 ACK/NAK 피드백은 보낸다.

## rdt 2.2

rdt 2.2에서는 NAK를 없애고 ACK 만으로 동일하게 동작한다.

수신자가 받은 패킷에 오류가 있다면 NAK가 아니라 ACK와 함께 시퀀스 번호를 보낸다.

이때 함께 보내지는 시퀀스 번호는 수신자가 기다리는 시퀀스 번호가 아닌 이전에 정상적으로 받았던 패킷의 시퀀스 번호를 보낸다. 오류가 없다면 시퀀스 번호는 수신자가 기다리고 있던 시퀀스 번호이다.

송신자는 피드백으로 받은 ACK의 시퀀스 번호와 보냈던 패킷의 시퀀스 번호가 다르면 문제가 있는 것으로 판단하고 패킷을 재전송한다.

## rdt 3.0

rdt 3.0은 rdt 2.2에서 패킷 손상에 대한 해결 알고리즘과 더불어 패킷 손실에 대해도 고려한다. 패킷 손실은 패킷이 송수신 되는 과정 중 유실되었음을 의미한다.

패킷 손실 문제는 위해 송신자는 패킷을 보냄과 동시에 피드백(ACK)를 받기까지 일정 시간(**Timer**)을 기다리고 이 시간이 지나면 유실된 것으로 판단하고 보냈던 패킷을 재전송하는 알고리즘으로 해결한다.

이 타이머의 수치를 어떻게 설정하냐는 것이 관건이다.

만약 타이머 시간이 짧다면 패킷 유실을 빠르게 판단하고 재전송할 수 있지만, 수신측에서는 응답 메시지를 보냈지만 라우터간 지연 등의 문제로 제대로 오고 있지만 이를 못기다리고 재전송을 해버릴 수 있는 것이다.

타이머 시간이 길다면, 위 문제에 대한 걱정은 어느정도 내려놓을 수도 있지만 실제 패킷 손실이 있을 때 리액션이 늦다는 단점이 있다.

타이머 시간 설정에 대해서 정답은 없기 때문에 엔지니어링 관점에서의 고민이 필요하다. 일반적인 방법으로는 RTT(Round-Trip-Time) 시간보다 조금 여유를 둘 수 있다.

# 정리

- TCP는 신뢰성 있는 데이터 전달을 보장하는 프로토콜이고 rdt를
- rdt는 불안정한 네트워크 상에서 발생할 수 있는 이슈인 패킷 손상, 패킷 손실을 극복하는 전송 계층의 프로토콜이다.
- 문제를 해결하기 위해 다음 필드들을 이용한다.
    - 에러 검출: Checksum
    - 패킷을 잘 받았는지 피드백: ACK
    - 중복된 패킷인지 확인 : Sequence Number
    - 패킷 유실로 판단: Timer
- TCP는 지금까지 살펴본 것처럼 매번 메시지를 보내고 기다린다면(Stop&Go) 매우 느릴 것이다. TCP는 실제로 이렇지 않다.
    - 다음 시간에..