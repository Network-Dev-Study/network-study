# 트랜스포트 계층 서비스 및 개요
트랜스포트 계층 프로토콜은 **프로세스 사이의 논리적 통신**을 제공한다. 논리적 통신은 애플리케이션 관점에서 봤을 때 프로세스들이 동작하는 호스트들이 직접 연결되어 보인다는 것을 의미한다. 애플리케이션은 메시지 운반에 필요한 물리적 인프라스트럭처의 세부 사항에 상관없이 서로 메시지를 송신하기 위해 트랜스포트 계층에서 제공하는 논리적 통신을 사용한다.

애플리케이션에서 메시지 송신 시 트랜스포트 계층 전후 흐름
1. 애플리케이션에서 메시지 송신
2. 트랜스포트 계층에서 애플리케이션으로부터 메시지를 수신하고 **세그먼트**(segment)라고 알려진 트랜스포트 계층의 패킷으로 변환
3. 변환 과정에서 메시지 추가적으로 트랜스포트 계층만의 헤더를 추가
4. 네트워크 계층으로 세그먼트를 전달

## 트랜스포트 계층과 네트워크 계층 사이의 관계
트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 **프로세스들** 사이의 논리적 통신을 제공하고, 네트워크 계층 프로토콜은 **호스트들** 사이의 논리적 통신을 제공한다.

트랜스포트 계층과 네트워크 계층의 역할에 차이점을 책에서 설명한 비유를 통해 알아보자면...
- 애플리케이션 메시지 = 편지
- 프로세스 = 집 내부 구성원들
- 호스트 = 집
- 트랜스포트 계층 프로토콜 = 집 구성원들 중 편지를 나눠주는 책임을 가진 구성원
- 네트워크 계층 프로토콜 = 집 밖에서 다른 집으로까지 편지를 배달하는 역할

트랜스포트 계층이 제공할 수 있는 서비스는 하위 네트워크 계층 프로토콜의 서비스 모델에 의해 제약받는다. 만약 네트워크 계층 프로토콜이 호스트 사이에서 전송되는 트랜스포트 계층 세그먼트에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다면, 트랜스포트 계층 프로토콜은 프로세스끼리 전송하는 메시지에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다.

그럼에도 불구하고 하위 네트워크 프로토콜이 상응하는 서비스들을 제공하지 못할 때도, 특정 서비스는 트랜스포트 프로토콜에 의해 제공될 수 있다. 예를 들어 하위 네트워크 프로토콜이 비신뢰적이어도 애플맄케이션에게 신뢰적인 데이터 전송 서비스를 제공할 수 있다.

## 인터넷 트랜스포트 계층의 개요
인터넷은 애플리케이션 계층에게 두 가지로 구별되는 트랜스포트 계층 프로토콜을 제공하며, 개발자는 개발 단계에서 애플리케이션 서비스 특징에 따라 두 가지 프로토콜 중 하나를 선택해야 한다. (소켓 생성 예제 코드에서 시 TCP/UDP 선택하던 내용 상기)
- UDP: 비신뢰적, 비연결형
- TCP: 신뢰적, 연결지향형

인터넷 상에서 트랜스포트 계층에서 다루는 패킷에 대한 용어가 세그먼트, 데이터그램 등으로 혼재되어 사용되는데 책에서는 TCP, UDP 패킷 모두 세그먼트로 지칭하고 네트워크 계층 패킷에 대해서는 데이터그램이란 용어를 사용한다.

UDP와 TCP 소개에 앞서, 인터넷의 네트워크 계층에 대해 살펴보자.
인터넷의 네트워크 계층 프로토콜은 인터넷 프로토콜(Internet Protocol, IP)라는 이름을 갖는다. IP 서비스 모델은 호스트들 간에 논리적 통신을 제공하는 **최선형 전달 서비스**(best-effort delivery service)이다. 이는 IP가 통신하는 호스트들 간에 **세그먼트를 전달하기 위해 최선을 다하지만, 어떠한 보장도 하지 않는다는 것을 의미**한다. 이러한 이유로 IP를 비신뢰적인 서비스라고 부른다. 또한 **모든 호스트는 적어도 하나의 IP 주소를 갖고 있다.**

UDP와 TCP의 가장 기본적인 기능은 호스트 사이의 IP 전달 서비스를 호스트 사이에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것이다. 즉, '호스트 대 호스트 전달'을 '프로세스 대 프로세스 전달'로 확장하는 것을 트랜스포트 계층 **다중화**(multiplexing)와 **역다중화**(demultiplexing)라고 부른다.

UDP와 TCP는 헤더에 오류 검출 필드를 포함함으로써 무결성 검사를 제공한다. 이렇게 UDP는 최소한의 두 가지 트랜스포트 계층 서비스(데이터 전달, 오류 검출)만을 제공한다. UDP는 앞서 살펴본 IP와 마찬가지로 전송하는 데이터가 목적지까지 손상없이 도착하는 것을 보장하지 않는 비신뢰적인 서비스이다.
반면에, TCP는 애플리케이션에 몇 가지 추가적인 서비스를 제공한다.
- **신뢰적인 데이터 전송(reliable data transfer)**
    - 흐름 제어, 순서 번호, 확인 응답, 타이머를 사용하여 프로세스 간에 전달하는 데이터가 순서대로 정확하게 전달되도록 확실히 보장함
    - 이처럼 TCP는 호스트 간에 IP의 비신뢰적인 서비스를 프로세스 사이의 신뢰적인 데이터 전송 서비스로 만들어주는 역할을 함
- **혼잡 제어(congestion control)**
    - 특정 애플리케이션만을 위하지 않고 전체를 위한 서비스
    - TCP 연결이 과도한 양의 트래픽으로 모든 통신하는 호스트들 사이의 스위치와 링크를 혼잡하게 하는 상황을 방지하는 역할
    - 혼잡한 네트워크 링크에서 각 TCP 연결이 링크의 대역폭을 공평하게 공유하여 통과할 수 있도록 해줌


# 다중화와 역다중화
역다중화(demultiplexing): 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업
다중화(multiplexing): 애플리케이션으로부터 데이터를 모으고, 세그먼트 생성을 위해 각 데이터에 헤더 정보로 캡슐화한 뒤, 세그먼트들을 네트워크 계층으로 전달하는 작업

![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/CN_Multiplexing-2.jpg)

다중화를 위해서는 소켓은 유일한 식별자를 가져야 하고 각 세그먼트는 세그먼트가 전달될 소켓을 가리키는 필드를 가져야 한다. 이 필드라는 것은 출발지 포트 번호 필드(source port number field)와 목적지 번호 필드(destination port number field)이다.
호스트이 각 소켓은 포트 번호를 가지며, 세그먼트가 호스트에 도착하면 트랜스포트 계층은 세그먼트 안의 목적지 포트 번호를 검사하고 사응하는 소켓으로 세그먼트를 보낸다. 그후 세그먼트의 데이터는 소켓을 통해 프로세스로 전달된다. 이는 UDP 동작 방식에서의 설명이며, TCP의 다중화/역다중화는 좀 더 많은 의미를 갖고있다.

## 비연결형 다중화와 역다중화

UDP 소켓 1111을 가진 호스트 A가 호스트 B의 UDP 소켓 7777을 가진 프로세스에게 데이터를 전송하는 시나리오에서 UDP 다중화/역다중화 흐름을 살펴보자.
1. 호스트 A의 트랜스포트 계층은 애플리케이션 데이터, 출발지 포트번호(1111), 목적지 포트번호(7777), 2개의 다른 필드값을 포함(나중 설명)하는 트랜스포트 계층 세그먼트를 생성 (다중화)
2. 트랜스포트 계층은 세그먼트를 네트워크 계층으로 전달
3. 네트워크 계층은 세그먼트를 IP 데이터그램으로 캡슐화하고 최선형 전달 서비스로 세그먼트를 수신 호스트 B로 전달
4. 세그먼트가 호스트 B에 도착하면, 세그먼트 안의 목적지 포트번호를 검사하고 해당 세그먼트와 일치하는 소켓에 전달 (역다중화)

UDP 소켓은 목적지 IP 주소와 목적지 포트 번호로 구성된 집합에 의해 식별된다. 만약 여러 UDP 세그먼트의 출발지 IP 주소, 포트 번호가 다를지라도 목적지 IP 주소, 포트 번호가 동일하다면 동일한 목적지의 프로세스로 향하는 것이다. UDP에서 출발지 정보는 회신 정보로 사용된다. 예로 호스트 B에서 메시지를 수신하고 세그먼트를 다시 A로 보내기 원할 때, A로 가는 목적지 포트 번호를 A로부터 받은 출발지 포트 번호로부터 가져오는 것이다.

## 연결형 다중화와 역다중화
UDP 소켓과 달리 TCP 소켓은 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호로 이루어진 총 4개의 요소의 집합으로 식별된다.
즉, 목적지 호스트에 TCP 세그먼트가 도착하면, 호스트는 상응하는 소켓으로 세그먼트를 전달(역다중화)하기 위해 4개의 값을 집합으로 식별한다. UDP 소켓의 경우 출발지 정보가 달라도 목적지만 같다면 같은 소켓으로 향했지만, TCP는 출발지와 목적지 정보가 전부 같아야 같은 소켓으로 향하게 된다. 이는 TCP의 특징과 관계가 있는 내용으로 클라이언트와 서버는 메시지를 보내기 전에 연결을 맺어야 하고, TCP 연결을 맺으면 서버는 해당 클라이언트만을 위한 소켓을 생성한다. 새롭게 생성된 TCP 소켓은 앞서 말한 4가지 값으로 식별된다.

## 웹 서버와 TCP
웹 서버가 포트를 어떻게 사용하는지와 관련해 몇가지를 살펴본다.

웹 서버는 Well-known Port인 80 포트를 갖고, 웹 서버로 들어오는 모든 세그먼트는 동일한 목적지 포트(80)을 갖고 있을 것이다. 이전에는 웹 서버의 요청 마다 각자의 연결 소켓을 갖는 프로세스를 생성하여 통신했었다고 한다.
그러나 연결 소켓과 프로세스 사이에 항상 일대일 대응만 이루어지는 것은 아니다. 현대의 웹서버는 하나의 프로세스만 사용하고 각각의 클라이언트 연결을 위해서는 새로운 연결 소켓과 함께 새로운 스레드를 생성한다. 생성과 소멸에 사용되는 비용이 프로세스에 비해 훨씬 적다.

만약 클라리언트가 서버와 지속적인 HTTP를 사용한다면, 연결 지속 기간 동안에는 클라이언트와 서버가 동일한 소켓을 통해 통신을 이루겠지만, 클라이언트와 서버가 비지속적인 HTTP를 사용한다면, 모든 요청/응답 마다의 새로운 소켓을 생성하고 종료시켜야 한다. 이는 곧 웹 서버의 부하로 이어지게 된다.

> HTTP 1.1 이후로 지속적 연결을 의미하는 Connection: keep-alived 옵션에 따라 요청이 끝나더라도 소켓을 유지하고 해당 소켓을 통해 통신할 수 있음
> 지정된 timeout 시간또는 서버에 설정된 시간이 지나면 소켓을 닫고 이후 요청에는 소켓을 새로 생성해야 함

# 비연결형 트랜스포트: UDP
앞서 보았듯이 UDP는 트랜스포트 프로토콜 중 최소한의 서비스인 데이터 전달, 오류 검출만을 제공한다. 이러한 점에서 UDP 애플리케이션은 거의 IP와 직접 통신하는 것으로 간주해도 어색하지 않다.
애플리케이션 개발 시 필요하다면 TCP가 아닌 UDP를 선택해야 하는 이유에 대해 살펴보자.

#### 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어
UDP는 애플리케이션의 데이터를 트랜스포트 계층에서 오래 붙잡지 않고 UDP 세그먼트로만 만든 뒤, 곧바로 네트워크 계층으로 전달한다. 반면에 TCP는 혼잡 제어 메커니즘 특성 때문에, 링크가 혼잡할 경우 트랜스포트 계층에서 TCP 송신을 제한할 수 있다. 실시간 애플리케이션은 최소 전송률을 요구할 때도 있고, 지나치게 지연되는 세그먼트 전송을 원하지 않으며, 조금의 데이터 손실은 허용할 수도 있기에 TCP 서비스 모델은 이러한 애플리케이션 특성과는 맞지 않다.
실시간 애플리케이션은 UDP를 사용하고, 애플리케이션 계층에서 UDP의 기본 세그먼트 전달 외 필요한 부분을 추가 구현하는 방법도 있다.

#### 연결 설정이 없음
TCP는 데이터 송수신 이전에 TCP 연결을 맺기 위해 3-way handshake 과정을 필요로 한다. UDP는 이러한 준비과정이 없으므로 연결 설정을 위한 어떠한 지연도 발생하지 않는다. DNS가 만약 TCP 기반이었다면 가벼운 질의를 건네는 빈번한 요청을 보내기 위해 TCP 연결을 매번 맺어야 하는 상황이 발생한다. 이는 배보다 배꼽이 더 커진 상황으로 볼 수 있다.

#### 연결 상태가 없음
TCP는 호스트 간에 연결 상태를 유지하며, 여러 파라미터를 포함한다. UDP는 연결을 유지하지 않고 파라미터 중 어느 것도 상태로 갖고 있지 않으므로 더 가벼워서 좀 더 많은 액티브 클라이언트를 수용할 수 있다.

#### 작은 패킷 헤더 오버헤드
TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP는 단지 8바이트의 오버헤드를 갖는다.

## UDP 세그먼트 구조
애플리케이션 데이터는 UDP 세그먼트의 데이터 필드에 위치한다. UDP 헤더는 2바이트씩 구성된 단 4개의 필드만을 갖는다.
- 출발지 포트, 목적지 포트: 역다중화를 위해 사용
- 체크섬: 세그먼트에 오류가 발생했는지를 검사하기 위해 사용
- 길이: 헤더를 포함하는 UDP 세그먼트의 길이(바이트 단위)

## UDP 체크섬
UDP 체크섬은 세그먼트가 출발지로부터 목적지까지 이동하면서 오류가 있었는지를 검사하는 것이다. 좀 더 자세히는, UDP 세그먼트 내의 비트에 대한 변경사항이 있는지 검사하는 것이다. 패킷에 오류가 없다면 수신자에서 합은 모두 1이어야 하지만, 비트 중 하나라도 0이 있다면 패킷에 오류가 있는 것이다.